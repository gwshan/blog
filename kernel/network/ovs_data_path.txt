
core/dev.c::__netif_receive_skb_core
(struct net_device::netdev_ops)
net/openvswitch/vport-netdev.c::netdev_frame_hook
net/openvswitch/vport-netdev.c::netdev_port_receive
   * Get vport from struct net_device::rx_handler_data
   * Clone skb if it's shared
net/openvswitch/vport.c::ovs_vport_receive
   net/openvswitch/flow.c::ovs_flow_key_extract
      * Fill struct sw_flow_key with information from the frame/packet
        (physical info, L2, L3 and tunnel if applicable)
net/openvswitch/datapath.c::ovs_dp_process_packet
   net/openvswitch/flow_table.c::ovs_flow_tbl_lookup_stats
      * Get struct sw_flow according to struct sw_flow_key
   * If the flow doesn't exist, the packet is forwarded to userspace via netlink.
   * Update flow's statistics (CPU local)
   net/openvswitch/actions.c::ovs_execute_actions
   net/openvswitch/actions.c::do_execute_actions
      * Apply the struct sw_flow_action (ACLs) that associated with the flow. So the
        packet can bed modified prior to forwarding. Also, the packet might be forwarded
        to userspace. Otherwise, the destination vport ID is determined by ACLs.
   net/openvswitch/actions.c::do_output
      * Check MTU of destination vport, to do framentation if necessary. This shouldn't
        be needed in common scenarios. Otherwise, the configuration needs to be changed
        for more performance.
   net/openvswitch/vports.c::ovs_vport_send
      * Drop ethernet header if destination vport can't handle it (ARPHRD_NONE)
      * Drop the packet if its length exceeds destination port's MTU.
      * call vport->ops->send(). There are several types of vport, each of them has its
        specific struct vport_ops. Take vport-netdev.c and TAP as example here as it might
        be mostly used combination.
   (net/openvswitch/vport-gre.c::ovs_gre_vport_ops                -> dev_queue_xmit)
   (net/openvswitch/vport-internal_dev.c::ovs_internal_vport_ops  -> internal_dev_recv)
   (net/openvswitch/vport-vxlan.c::ovs_vxlan_netdev_vport_ops     -> dev_queue_xmit)
   (net/openvswich/vport-geneve.c::ovs_geneve_vport_ops           -> dev_queue_xmit)
   (net/openvswitch/vport-netdev.c::ovs_netdev_vport_ops          -> dev_queue_xmit)
   drivers/net/tun.c::tun_net_xmit
      * Queue skb to the socket's Rx queue, wait for user to fetch. It should be
        received by QEMU in virtualized environment.
                  :
                  :
                  x
                  :
                  :
drivers/net/tun.c::tun_chr_write_iter
drivers/net/tun.c::tun_get_user
   * Copy the raw data into skb.
core/dev.c::netif_receive_skb
core/dev.c::netif_receive_skb_internal
core/dev.c::__netif_receive_skb
net/openvswitch/vport-netdev.c::netdev_frame_hook
net/openvswitch/vport-netdev.c::netdev_port_receive
                  :
                  :
   The skb received on the vport that is associated with the TAP. The flow is
   identified. The ACLs associated with the flow are applied. One of the ACLs
   should be responsible for forwarding the skb to upstream vport. After that,
   the packet is sent to the netdev that associated with the upstream vport.
                  :
                  : 

